name: CD Pipeline - Production Deployment

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment (skip checks)'
        required: false
        default: false
        type: boolean

env:
  HUSKY: 0
  NODE_VERSION: '20'
  DOCKER_HUB_USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
  DOMAIN: gymsmart.site
  DEV_ROLE_ID: ${{ secrets.DEV_ROLE_ID }}

jobs:
  test:
    name: Pre-deployment Tests
    runs-on: ubuntu-latest
    if: ${{ !inputs.force_deploy }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run full test suite
        env:
          NODE_ENV: ${{ secrets.NODE_ENV }}
          PORT: ${{ secrets.PORT }}
          MONGODB_URI: ${{ secrets.MONGODB_URI }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          JWT_EXPIRES_IN: ${{ secrets.JWT_EXPIRES_IN }}
          LOG_LEVEL: ${{ secrets.LOG_LEVEL }}
          CORS_ORIGIN: ${{ secrets.CORS_ORIGIN }}
          RATE_LIMIT_WINDOW_MS: ${{ secrets.RATE_LIMIT_WINDOW_MS }}
          RATE_LIMIT_MAX_REQUESTS: ${{ secrets.RATE_LIMIT_MAX_REQUESTS }}
        run: |
          npm run lint
          npm test
          npm run test:config

      - name: Security audit
        run: npm audit --audit-level high

  build-and-push:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: [test]
    if: always() && (needs.test.result == 'success' || inputs.force_deploy)

    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_HUB_USERNAME }}/sgms-backend
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Generate deployment summary
        run: |
          echo "## ğŸš€ Docker Image Built Successfully" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** \`${{ env.DOCKER_HUB_USERNAME }}/sgms-backend:latest\`" >> $GITHUB_STEP_SUMMARY
          echo "**SHA:** \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Size:** $(docker images ${{ env.DOCKER_HUB_USERNAME }}/sgms-backend:latest --format 'table {{.Size}}')" >> $GITHUB_STEP_SUMMARY

  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-and-push]
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH Agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Copy deployment files
        run: |
          echo "ğŸ” Pre-deployment connectivity checks..."

          # Test network connectivity with timeout
          echo "Testing ping to ${{ secrets.SSH_HOST }}..."
          if ! timeout 10 ping -c 2 ${{ secrets.SSH_HOST }}; then
            echo "âš ï¸ Ping failed - checking if server is behind proxy..."
          fi

          # Test SSH port with explicit timeout
          echo "Testing SSH port accessibility..."
          if ! timeout 10 nc -zv ${{ secrets.SSH_HOST }} 22; then
            echo "âŒ SSH port 22 is not accessible"
            echo "This usually means:"
            echo "1. Server firewall is blocking SSH"
            echo "2. Domain is proxied through Cloudflare (use direct IP)"
            echo "3. SSH is running on different port"
            echo "4. Server is down"
            exit 1
          fi

          # Test SSH authentication
          echo "ğŸ”‘ Testing SSH authentication..."
          if ! ssh -o StrictHostKeyChecking=no -o ConnectTimeout=15 -o BatchMode=yes ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "echo 'SSH connection successful'; whoami"; then
            echo "âŒ SSH authentication failed"
            echo "Check:"
            echo "1. SSH private key is correct"
            echo "2. Public key is in ~/.ssh/authorized_keys"
            echo "3. SSH service is running on server"
            exit 1
          fi

          echo "âœ… SSH connection verified successfully"

          echo "ğŸ“ Copying deployment files..."
          # Copy with retry mechanism
          for file in docker-compose.prod.yml nginx.conf; do
            echo "Copying $file..."
            if ! scp -o StrictHostKeyChecking=no -o ConnectTimeout=30 -o ServerAliveInterval=60 -P 22 "$file" ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }}:~/sgms-backend/; then
              echo "âŒ Failed to copy $file"
              exit 1
            fi
            echo "âœ… Successfully copied $file"
          done

      - name: Deploy to production
        id: deploy
        run: |
          # Function to retry SSH commands
          retry_ssh() {
            local cmd="$1"
            local max_attempts=3
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "ğŸ”„ Attempt $attempt/$max_attempts: $cmd"
              if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 -o ServerAliveInterval=60 -p 22 ${{ secrets.SSH_USERNAME }}@${{ secrets.SSH_HOST }} "$cmd"; then
                echo "âœ… Command executed successfully"
                return 0
              else
                echo "âŒ Attempt $attempt failed"
                if [ $attempt -eq $max_attempts ]; then
                  echo "ï¿½ All attempts failed"
                  return 1
                fi
                echo "â³ Waiting 10 seconds before retry..."
                sleep 10
                attempt=$((attempt + 1))
              fi
            done
          }

          # Execute deployment commands with retry (force clean state)
          retry_ssh "cd ~/sgms-backend && echo 'ğŸ§¹ Force resetting to clean state...' && git reset --hard HEAD"
          retry_ssh "cd ~/sgms-backend && echo 'ğŸ”„ Pulling latest code...' && git pull origin main"
          retry_ssh "echo 'ğŸ—ï¸ Pulling latest Docker image...' && docker pull ${{ env.DOCKER_HUB_USERNAME }}/sgms-backend:latest"
          retry_ssh "cd ~/sgms-backend && echo 'ğŸš€ Deploying application...' && chmod +x deploy.sh && ./deploy.sh"
          retry_ssh "echo 'âœ… Deployment completed!'"

      - name: Health check
        run: |
          echo "ğŸ¥ Running health checks..."
          sleep 30

          # Try both HTTP and HTTPS
          HEALTH_CHECK_HTTP=$(curl -s --max-time 10 http://${{ secrets.SSH_HOST }}/api/health || echo "failed")
          HEALTH_CHECK_HTTPS=$(curl -s --max-time 10 -k https://${{ secrets.SSH_HOST }}/api/health || echo "failed")
          HEALTH_CHECK_API=$(curl -s --max-time 10 -k https://api.gymsmart.site/api/health || echo "failed")

          echo "HTTP Health Check: $HEALTH_CHECK_HTTP"
          echo "HTTPS Health Check: $HEALTH_CHECK_HTTPS"  
          echo "API Domain Health Check: $HEALTH_CHECK_API"

          if [[ $HEALTH_CHECK_HTTP == *"success"* ]] || [[ $HEALTH_CHECK_HTTPS == *"success"* ]] || [[ $HEALTH_CHECK_API == *"success"* ]]; then
            echo "âœ… Health check passed!"
            echo "HEALTH_STATUS=healthy" >> $GITHUB_ENV
          else
            echo "âš ï¸ Health check failed, but continuing..."
            echo "HEALTH_STATUS=check_failed" >> $GITHUB_ENV
            # Don't exit 1 to allow deployment to complete
          fi

      - name: Deployment summary
        run: |
          echo "## ğŸ‰ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** âœ… Success" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** Production" >> $GITHUB_STEP_SUMMARY
          echo "**Server:** \`${{ secrets.SSH_HOST }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Health:** ${{ env.HEALTH_STATUS }}" >> $GITHUB_STEP_SUMMARY
          echo "**API URL:** https://${{ secrets.SSH_HOST }}/api" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed at:** $(date -u)" >> $GITHUB_STEP_SUMMARY

  notify:
    name: Notify Team
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always()

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Notify Discord on Success
        if: needs.deploy.result == 'success'
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
          DEV_ROLE_ID: ${{ secrets.DEV_ROLE_ID }}
          BRANCH_NAME: ${{ github.ref_name }}
          COMMIT_SHA: ${{ github.sha }}
          COMMIT_AUTHOR: ${{ github.actor }}
        run: |
          # Get commit message
          COMMIT_MSG=$(git log -1 --pretty=format:'%s' 2>/dev/null || echo "Direct deployment")
          
          curl -X POST "$DISCORD_WEBHOOK" \
            -H "Content-Type: application/json" \
            -d '{
              "content": "<@&'"$DEV_ROLE_ID"'>",
              "embeds": [{
                "title": "ğŸš€ SGMS Backend Deployed Successfully",
                "description": "ğŸŒ¿ **Branch:** `'"$BRANCH_NAME"'`\nğŸ“¦ **Commit:** `'"${COMMIT_SHA:0:8}"'`\nğŸ’¬ **Message:** `'"$COMMIT_MSG"'`\nğŸ‘¤ **Author:** ['"$COMMIT_AUTHOR"'](https://github.com/'"$COMMIT_AUTHOR"')\nğŸ”— **API:** https://api.gymsmart.site/api",
                "color": 3066993,
                "footer": {
                  "text": "ğŸ•’ Deployed at '"$(date -u +"%Y-%m-%d %H:%M:%S UTC")"'"
                },
                "thumbnail": {
                  "url": "https://github.com/'"$COMMIT_AUTHOR"'.png"
                }
              }]
            }'

      - name: Notify Discord on Failure
        if: needs.deploy.result == 'failure'
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
          DEV_ROLE_ID: ${{ secrets.DEV_ROLE_ID }}
          BRANCH_NAME: ${{ github.ref_name }}
          COMMIT_SHA: ${{ github.sha }}
          COMMIT_AUTHOR: ${{ github.actor }}
        run: |
          # Get commit message
          COMMIT_MSG=$(git log -1 --pretty=format:'%s' 2>/dev/null || echo "Direct deployment")
          
          curl -X POST "$DISCORD_WEBHOOK" \
            -H "Content-Type: application/json" \
            -d '{
              "content": "<@&'"$DEV_ROLE_ID"'>",
              "embeds": [{
                "title": "âŒ SGMS Backend Deployment Failed",
                "description": "ğŸŒ¿ **Branch:** `'"$BRANCH_NAME"'`\nğŸ“¦ **Commit:** `'"${COMMIT_SHA:0:8}"'`\nğŸ’¬ **Message:** `'"$COMMIT_MSG"'`\nğŸ‘¤ **Author:** ['"$COMMIT_AUTHOR"'](https://github.com/'"$COMMIT_AUTHOR"')\nğŸ”— **Check:** [View Logs](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})",
                "color": 15158332,
                "footer": {
                  "text": "ğŸ•’ Failed at '"$(date -u +"%Y-%m-%d %H:%M:%S UTC")"'"
                },
                "thumbnail": {
                  "url": "https://github.com/'"$COMMIT_AUTHOR"'.png"
                }
              }]
            }'
